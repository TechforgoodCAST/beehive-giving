exit
exjt
subject.errors.full_messages
subject.reload
reload
exit
subject.errors.full_messages
subject.update(districts: [district])
subject.errors.full_messages
exit
subject.update(districts: [district])
subject.errors.full_messages
exit
subject.errors.full_messages
subject.update(districts: [district])
subject.errors.full_messages
subject.valid?
subject.errors.full_messages
subject.errors
exit
      find('.choices').click
find('#choices-proposal_theme_ids-item-choice-1')
exit
puts page.body
find('#choices-recipient_district_id-item-choice-1')
puts page.body
page.has_css?('#choices-recipient_district_id-item-choice-1')
puts page.body
exit
Capybara.default_max_wait_time
exit
Timeout::timeout(1) { 'hi' }
Timeout.timeout(1) { 'hi' }
Timeout.timeout(1)
Timeout.timeout
Timeout.parent
page.evaluate_script("document.getElementById('choices-recipient_district_id-item-choice-0')")
page.evaluate_script("document.getElementById('choices-recipient_district_id-item-choice-1')")
exit
self.class::CATEGORIES
class::CATEGORIES
self::CATEGORIES
self
super.class
exit
subject[0].reasons.keys
subject[0].reasons
subject[0]
subject
exit
subject.districts
exit
subject.country_ids
subject.valid?
subject.country_ids
subject.country_id = country.id
subject.country_ids
subject.valid?
subject.country_ids
subject.country_id
exit
subject.country_id
subject.country_ids
exit
subject
exit
subject.country_id
subject.country_ids
exit
subject.country_id
subject.country_ids
exit
subject.countries
exit
subject.countries
sub.country_ids
exit
sub.country_ids
sub.countries = []
sub.countries
sub.country_ids
sub = build(:proposal)
subject.country_ids
subject.country_id
exit
sub.country_ids
sub.country_id
sub.country
propoal.country_id
propoal.country
sub = build(:proposal)
subject.country_ids
exit
subject.country_ids
subject.country_id
exit
country_ids
self.country_ids
self[:country_ids]
self[:country_ids)
international?
geographic_scale
country_id
exit
subject.country_ids
exit
subject.country_ids
subject.country_id
subject.country_id = 1
subject.country_id
exit
Assessment.analyse_and_update!(collection.funds, proposal)
exit
old == Assessment.all
Assessment.analyse_and_update!(collection.funds, proposal)
proposal.update_column(:min_amount, 1)
proposal.update!(min_amount: 1)
old = Assessment.all
Assessment.all
Assessment.analyse_and_update!(collection.funds, proposal)
Assessment.count
exit
Assessment.count
Assessment.analyse_and_update!(collection.funds, proposal)
proposal.update!(min_amount: 1)
proposal.update!(min_amount: 0)
proposal.update(min_amount: 0)
proposal.min_amount
collection.funds.first.proposal_min_amount
collection.funds.first.min_amount
collection.funds.first
exit
emails.size
emails[1].subject
exit
emails[1].subject
emails[0].subject
exit
Country.count
Proposal.last.countries
@country
exit
Country.count
Proposal.last.countries
@country
exit
collection.restrictions.where(category: 'Proposal').limit(2)
collection.restrictions.where(category: 'Proposal').group(:invert).count
collection.priorities.where(category: 'Proposal').group(:invert).count
collection.priorities.where(category: 'Proposal').limit(2)
collection.priorities.where(category: 'Proposal').size
collection.priorities.where(category: 'Proposal').szie
collection.priorities.where(category: 'Proposal')
puts page.body
collection.restrictions.where(category: 'Proposal')
collection.restrictions.where(category: 'Proposal').each.odd { |u| }
collection.restrictions.where(category: 'Proposal').odd { |u| }
collection.restrictions.where(category: 'Proposal').size
puts page.body
exit
collection.restrictions.where(category: 'Proposal').limit(2).update_all(invert: true)
collection.restrictions.where(category: 'Proposal').limit(2).update_all!(invert: true)
collection.restrictions.where(category: 'Proposal').limit(2).update_all(invert: true)
collection.restrictions.where(category: 'Proposal').group(:invert).count
collection.restrictions.where(category: 'Proposal').last(2).each { |u| u.update(invert: true) }
collection.restrictions.where(category: 'Proposal').last(2).update_all(invert: true)
collection.restrictions.where(category: 'Proposal').last(2).update(invert: true)
collection.restrictions.where(category: 'Proposal').group(:invert).count
collection.restrictions.where(category: 'Proposal').pluck(:invert)
puts page.body
exit
puts page.body
exit
puts page.body
collection.restrictions.where(category: 'Proposal').size
collection.restrictions.where(category: 'Proposal').soze
collection.restrictions.where(category: 'Proposal')
exit
reload
reload!
'unclear' if values.any? { |v| v == INCOMPLETE }
'avoid' if values.any? { |v| v == INELIGIBLE }
'approach' if values.all? { |v| v == ELIGIBLE }
values
exit
updates[0].reasons_change[1]
updates[0].reasons_change[0]
updates[0].reasons_change
updates[0].changes
next
exit
next
finish
finisg
next
updates[0].changes
next
exit
;10D
next
finish
next
exit
update.changes[1]
next
update.changes[1]
update.changes[0]
update.changes
exit
updates[0].changed?
updates[0].changes
next
updates[0].changes
updates[0].changed?
updates[0].reasons_change
exit
finish
next
finish
next
finish
next
u.changes
u.changed?
exit
u
exit
updates[0].reasons_change[0] == updates[0].reasons_change[1]
updates[0].reasons_change[1].class
updates[0].reasons_change[1].object_id
updates[0].reasons_change[0].object_id
updates[0].reasons_change[0]
updates[0].reasons_change
updates[0].reasons
next
updates[0].reasons
updates[0].reasons_change
updates[0].changes
updates[0].reasons_change
updates[0].changes
updates[0].reasons
exit
next
updates[0].reasons
updates[0].changes
Assessment.first.reasons
updates[0].reasons_change
updates[0].reasons_was
next
finish
exit
updates[0].reasons
updates[0].reasons_was
updates[0].reasons_change
updates[0].reasons_changes
updates[0].reasons_was
